export class KleverWeb {
    constructor(address, pvd) {
        if (address && address.length != 62) {
            throw new Error("invalid address length");
        }
        const provider = {
            node: pvd?.node || "https://node.mainnet.klever.org",
            api: pvd?.api || "https://api.mainnet.klever.org",
        };
        if (!globalThis.kleverWeb) {
            globalThis.kleverWeb = {
                address: address || "",
                provider,
            };
        }
        else {
            globalThis.kleverWeb.address = address || "";
            globalThis.kleverWeb.provider = provider;
        }
    }
    setWalletAddress = (address) => {
        if (address.length != 62) {
            throw new Error("invalid address length");
        }
        globalThis.kleverWeb.address = address;
    };
    getWalletAddress = () => {
        return globalThis.kleverWeb.address;
    };
    setProvider = (provider) => {
        globalThis.kleverWeb.provider = provider;
    };
    getProvider = () => {
        return globalThis.kleverWeb.provider;
    };
    getBalance = async () => {
        const request = await fetch(`${globalThis.kleverWeb.provider.api}/v1.0/address/${globalThis.kleverWeb.address}`);
        if (!request.ok) {
            throw new Error(`Failed to fetch balance: ${request.statusText}`);
        }
        const response = await request.json();
        if (response.code !== "successful") {
            throw new Error(`Error fetching balance of account ${globalThis.kleverWeb.address}: ${response.error}`);
        }
        return response.data.account.balance;
    };
    getAccountDetails = async () => {
        const request = await fetch(`${globalThis.kleverWeb.provider.api}/v1.0/address/${globalThis.kleverWeb.address}`);
        if (!request.ok) {
            throw new Error(`Failed to fetch account details: ${request.statusText}`);
        }
        const response = await request.json();
        if (response.code !== "successful") {
            throw new Error(`Error fetching account details of account ${globalThis.kleverWeb.address}: ${response.error}`);
        }
        return response.data.account;
    };
    getAssetBalance = async (assetId) => {
        const account = await this.getAccountDetails();
        const hasAsset = Object.keys(account.assets).find((id) => id === assetId);
        if (!hasAsset) {
            throw new Error(`Account ${globalThis.kleverWeb.address} does not have asset with id ${assetId}`);
        }
        return account.assets[assetId]?.balance || 0;
    };
    getAssetBalanceAndPrecision = async (assetId) => {
        const account = await this.getAccountDetails();
        const hasAsset = Object.keys(account.assets).find((id) => id === assetId);
        if (!hasAsset) {
            throw new Error(`Account ${globalThis.kleverWeb.address} does not have asset with id ${assetId}`);
        }
        return {
            balance: account.assets[assetId]?.balance || 0,
            precision: account.assets[assetId]?.precision || 0,
        };
    };
    getNonce = async () => {
        const req = await fetch(`${globalThis.kleverWeb.provider.node}/address/${globalThis.kleverWeb.address}/nonce`);
        return (await req.json());
    };
    buildTransactionWithHash = async (contracts, txData, options) => {
        if (contracts?.length === 0) {
            throw "empty contracts";
        }
        const fistContractType = contracts[0]?.type;
        const payloads = contracts.map((contract) => {
            return { ...contract.payload, contractType: contract.type };
        });
        const nonce = options?.nonce
            ? options.nonce
            : (await this.getNonce())?.data?.nonce || 0;
        const permID = options?.permID || 0;
        const kdaFee = options?.kdaFee || "";
        const txBody = {
            type: fistContractType,
            nonce,
            sender: options?.sender || globalThis?.kleverWeb?.address,
            data: txData || [],
            permID,
            contracts: payloads,
            kdaFee,
        };
        const req = await fetch(`${options?.provider?.node || globalThis?.kleverWeb?.provider?.node}/transaction/send`, {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify(txBody),
        });
        const res = await req.json();
        if (res?.error)
            throw res?.error;
        if (!res?.data && !res?.data?.result) {
            throw "failed to generate transaction";
        }
        return res.data;
    };
    buildTransaction = async (contracts, txData, options) => {
        const tx = await this.buildTransactionWithHash(contracts, txData, options);
        return tx.result;
    };
    getFees = async (contracts, txData, options) => {
        const tx = await this.buildTransaction(contracts, txData, options);
        const KAppFee = tx.RawData.KAppFee;
        const BandwidthFee = tx.RawData.BandwidthFee;
        return {
            KAppFee,
            BandwidthFee,
            TotalFee: KAppFee + BandwidthFee,
        };
    };
    broadcastTransactions = async (txs) => {
        const res = await fetch(`${globalThis.kleverWeb.provider.node}/transaction/broadcast`, {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({ txs: [...txs] }),
        });
        return await res.json();
    };
    signTransaction = globalThis?.kleverWeb?.signTransaction;
    signMessage = globalThis?.kleverWeb?.signMessage;
    validateSignature = globalThis?.kleverWeb?.validateSignature;
}
export default KleverWeb;
