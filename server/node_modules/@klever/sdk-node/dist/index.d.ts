export { IAssetTrigger, IBuyOrder, ICancelMarketOrder, IClaim, IConfigITO, IConfigMarketplace, IConfigValidator, ICreateAsset, ICreateMarketplace, ICreateValidator, IDelegate, IDeposit, IFreeze, IITOTrigger, IProposal, ISellOrder, ISetAccountName, ISetITOPrices, ITransfer, IUndelegate, IUnfreeze, IUnjail, IUpdateAccountPermission, IVotes, IWithdraw } from '@klever/kleverweb/dist/types/contracts';
import { IContractRequest, ITxOptionsRequest, ITransaction, IBroadcastResponse, IProvider, IFees } from '@klever/kleverweb/dist/types/dtos';
export { IContract, IContractRequest, IProvider, ITransaction, ITxOptionsRequest } from '@klever/kleverweb/dist/types/dtos';
import { TransactionType } from '@klever/kleverweb/dist/types/enums';
export { TransactionType, TriggerType } from '@klever/kleverweb/dist/types/enums';
import { BinaryWriter, BinaryReader } from '@bufbuild/protobuf/wire';
import { FileDescriptorProto } from 'ts-proto-descriptors';

interface IAccountInfo {
    address: string;
    nonce: number;
    rootHash: string;
    balance: number;
    allowance: number;
    timestamp: number;
}
interface IAccountResponse {
    data: {
        account: IAccountInfo;
    };
    error: string;
    code: string;
}
interface ITransactionContract {
    type: TransactionType;
    typeString: string;
    parameter: any;
}
interface IDecodedTransaction {
    data: {
        tx: {
            hash: string;
            sender: string;
            nonce: number;
            data: string[];
            kAppFee: number;
            bandwidthFee: number;
            status: string;
            version: number;
            chainID: string;
            searchOrder: number;
            contract: ITransactionContract[];
        };
    };
    error: string;
    code: string;
}

declare class Account {
    private privateKey;
    private address;
    private balance;
    private nonce;
    ready: Promise<void>;
    constructor(privateKey?: string, sync?: boolean);
    private init;
    getBalance(): number;
    getNonce(): number;
    getAddress(): string;
    sync(): Promise<void>;
    getInfo(): Promise<IAccountInfo>;
    buildTransaction: (contracts: IContractRequest[], txData?: string[], options?: ITxOptionsRequest) => Promise<ITransaction>;
    signMessage: (message: string) => Promise<string>;
    signTransaction: (tx: ITransaction) => Promise<ITransaction>;
    quickSend: (contracts: IContractRequest[], txData?: string[], options?: ITxOptionsRequest) => Promise<IBroadcastResponse>;
    downloadAsPem: (path?: string) => Promise<void>;
    validateSignature: (message: string, signature: string) => Promise<boolean>;
    broadcastTransactions: (txs: ITransaction[] | string[]) => Promise<IBroadcastResponse>;
}

interface IParsedNetworkParam {
    number: number;
    currentValue: string;
    parameterLabel: string;
}

declare const utils: {
    getAddressFromPrivateKey: (privateKey: string) => Promise<string>;
    generateKeyPair: () => Promise<{
        privateKey: string;
        address: string;
    }>;
    getProviders: () => IProvider;
    setProviders: (providers: IProvider) => void;
    broadcastTransactions: (txs: ITransaction[] | string[]) => Promise<IBroadcastResponse>;
    decodeTransaction: (tx: ITransaction) => Promise<IDecodedTransaction>;
    transactionsProcessed: (txs: Promise<IBroadcastResponse>[], tries?: number) => Promise<IDecodedTransaction[]>;
    accountsReady: (accounts: Account[]) => Promise<void>;
    decodeAddress: (address: string) => Promise<Uint8Array>;
    encodeAddress: (address: Uint8Array) => string;
    toHex: (data: Uint8Array) => string;
    fromHex: (hex: string) => Uint8Array;
    validateSignature: (message: string, signature: string, address: string) => Promise<boolean>;
    validateAddress: (address: string) => Promise<boolean>;
    calculateFees: (contractType: TXContract_ContractType, { data, network, networkParams, }: {
        data?: string | undefined;
        network?: string | undefined;
        networkParams?: IParsedNetworkParam[] | undefined;
    }) => Promise<IFees>;
    getNetworkParams: (network?: string) => Promise<IParsedNetworkParam[]>;
    getCleanType: (abiType: string, toLower?: boolean) => string;
    getJSType: (abiType: string) => string;
};

declare const protobufPackage$1 = "google.protobuf";
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a
 * URL that describes the type of the serialized message.
 *
 * Protobuf library provides support to pack/unpack Any values in the form
 * of utility functions or additional generated methods of the Any type.
 *
 * Example 1: Pack and unpack a message in C++.
 *
 *     Foo foo = ...;
 *     Any any;
 *     any.PackFrom(foo);
 *     ...
 *     if (any.UnpackTo(&foo)) {
 *       ...
 *     }
 *
 * Example 2: Pack and unpack a message in Java.
 *
 *     Foo foo = ...;
 *     Any any = Any.pack(foo);
 *     ...
 *     if (any.is(Foo.class)) {
 *       foo = any.unpack(Foo.class);
 *     }
 *     // or ...
 *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
 *       foo = any.unpack(Foo.getDefaultInstance());
 *     }
 *
 *  Example 3: Pack and unpack a message in Python.
 *
 *     foo = Foo(...)
 *     any = Any()
 *     any.Pack(foo)
 *     ...
 *     if any.Is(Foo.DESCRIPTOR):
 *       any.Unpack(foo)
 *       ...
 *
 *  Example 4: Pack and unpack a message in Go
 *
 *      foo := &pb.Foo{...}
 *      any, err := anypb.New(foo)
 *      if err != nil {
 *        ...
 *      }
 *      ...
 *      foo := &pb.Foo{}
 *      if err := any.UnmarshalTo(foo); err != nil {
 *        ...
 *      }
 *
 * The pack methods provided by protobuf library will by default use
 * 'type.googleapis.com/full.type.name' as the type URL and the unpack
 * methods only use the fully qualified type name after the last '/'
 * in the type URL, for example "foo.bar.com/x/y.z" will yield type
 * name "y.z".
 *
 * JSON
 * ====
 * The JSON representation of an `Any` value uses the regular
 * representation of the deserialized, embedded message, with an
 * additional field `@type` which contains the type URL. Example:
 *
 *     package google.profile;
 *     message Person {
 *       string first_name = 1;
 *       string last_name = 2;
 *     }
 *
 *     {
 *       "@type": "type.googleapis.com/google.profile.Person",
 *       "firstName": <string>,
 *       "lastName": <string>
 *     }
 *
 * If the embedded message type is well-known and has a custom JSON
 * representation, that representation will be embedded adding a field
 * `value` which holds the custom JSON in addition to the `@type`
 * field. Example (for message [google.protobuf.Duration][]):
 *
 *     {
 *       "@type": "type.googleapis.com/google.protobuf.Duration",
 *       "value": "1.212s"
 *     }
 */
interface Any {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com. As of May 2023, there are no widely used type server
     * implementations and no plans to implement one.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    type_url?: string | undefined;
    /** Must be a valid serialized protocol buffer of the above specified type. */
    value?: Uint8Array | undefined;
}
declare const Any: MessageFns$2<Any>;
type ProtoMetaMessageOptions$1 = {
    options?: {
        [key: string]: any;
    };
    fields?: {
        [key: string]: {
            [key: string]: any;
        };
    };
    oneof?: {
        [key: string]: {
            [key: string]: any;
        };
    };
    nested?: {
        [key: string]: ProtoMetaMessageOptions$1;
    };
};
interface ProtoMetadata$1 {
    fileDescriptor: FileDescriptorProto;
    references: {
        [key: string]: any;
    };
    dependencies?: ProtoMetadata$1[];
    options?: {
        options?: {
            [key: string]: any;
        };
        services?: {
            [key: string]: {
                options?: {
                    [key: string]: any;
                };
                methods?: {
                    [key: string]: {
                        [key: string]: any;
                    };
                };
            };
        };
        messages?: {
            [key: string]: ProtoMetaMessageOptions$1;
        };
        enums?: {
            [key: string]: {
                options?: {
                    [key: string]: any;
                };
                values?: {
                    [key: string]: {
                        [key: string]: any;
                    };
                };
            };
        };
    };
}
declare const protoMetadata$1: ProtoMetadata$1;
type Builtin$2 = Date | Function | Uint8Array | string | number | boolean | undefined;
type DeepPartial$2<T> = T extends Builtin$2 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial$2<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial$2<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial$2<T[K]>;
} : Partial<T>;
type KeysOfUnion$2<T> = T extends T ? keyof T : never;
type Exact$2<P, I extends P> = P extends Builtin$2 ? P : P & {
    [K in keyof P]: Exact$2<P[K], I[K]>;
} & {
    [K in Exclude<keyof I, KeysOfUnion$2<P>>]: never;
};
interface MessageFns$2<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter;
    decode(input: BinaryReader | Uint8Array, length?: number): T;
    fromJSON(object: any): T;
    toJSON(message: T): unknown;
    create<I extends Exact$2<DeepPartial$2<T>, I>>(base?: I): T;
    fromPartial<I extends Exact$2<DeepPartial$2<T>, I>>(object: I): T;
}

declare const any_d_Any: typeof Any;
declare namespace any_d {
  export {
    protobufPackage$1 as protobufPackage,
    any_d_Any as Any,
    ProtoMetadata$1 as ProtoMetadata,
    protoMetadata$1 as protoMetadata,
    DeepPartial$2 as DeepPartial,
    Exact$2 as Exact,
    MessageFns$2 as MessageFns,
  };
}

declare const protobufPackage = "proto";
declare enum CreateAssetContract_EnumAssetType {
    Fungible = 0,
    NonFungible = 1,
    SemiFungible = 2,
    UNRECOGNIZED = -1
}
declare function createAssetContract_EnumAssetTypeFromJSON(object: any): CreateAssetContract_EnumAssetType;
declare function createAssetContract_EnumAssetTypeToJSON(object: CreateAssetContract_EnumAssetType): number;
declare enum StakingInfo_InterestType {
    APRI = 0,
    FPRI = 1,
    UNRECOGNIZED = -1
}
declare function stakingInfo_InterestTypeFromJSON(object: any): StakingInfo_InterestType;
declare function stakingInfo_InterestTypeToJSON(object: StakingInfo_InterestType): number;
declare enum AssetTriggerContract_EnumTriggerType {
    Mint = 0,
    Burn = 1,
    Wipe = 2,
    Pause = 3,
    Resume = 4,
    ChangeOwner = 5,
    AddRole = 6,
    RemoveRole = 7,
    UpdateMetadata = 8,
    StopNFTMint = 9,
    UpdateLogo = 10,
    UpdateURIs = 11,
    ChangeRoyaltiesReceiver = 12,
    UpdateStaking = 13,
    UpdateRoyalties = 14,
    UpdateKDAFeePool = 15,
    StopRoyaltiesChange = 16,
    StopNFTMetadataChange = 17,
    ChangeAdmin = 18,
    UNRECOGNIZED = -1
}
declare function assetTriggerContract_EnumTriggerTypeFromJSON(object: any): AssetTriggerContract_EnumTriggerType;
declare function assetTriggerContract_EnumTriggerTypeToJSON(object: AssetTriggerContract_EnumTriggerType): number;
declare enum WithdrawContract_EnumWithdrawType {
    Staking = 0,
    KDAPool = 1,
    UNRECOGNIZED = -1
}
declare function withdrawContract_EnumWithdrawTypeFromJSON(object: any): WithdrawContract_EnumWithdrawType;
declare function withdrawContract_EnumWithdrawTypeToJSON(object: WithdrawContract_EnumWithdrawType): number;
declare enum ClaimContract_EnumClaimType {
    StakingClaim = 0,
    AllowanceClaim = 1,
    MarketClaim = 2,
    UNRECOGNIZED = -1
}
declare function claimContract_EnumClaimTypeFromJSON(object: any): ClaimContract_EnumClaimType;
declare function claimContract_EnumClaimTypeToJSON(object: ClaimContract_EnumClaimType): number;
declare enum VoteContract_EnumVoteType {
    Yes = 0,
    No = 1,
    UNRECOGNIZED = -1
}
declare function voteContract_EnumVoteTypeFromJSON(object: any): VoteContract_EnumVoteType;
declare function voteContract_EnumVoteTypeToJSON(object: VoteContract_EnumVoteType): number;
declare enum ConfigITOContract_EnumITOStatus {
    DefaultITO = 0,
    ActiveITO = 1,
    PausedITO = 2,
    UNRECOGNIZED = -1
}
declare function configITOContract_EnumITOStatusFromJSON(object: any): ConfigITOContract_EnumITOStatus;
declare function configITOContract_EnumITOStatusToJSON(object: ConfigITOContract_EnumITOStatus): number;
declare enum ITOTriggerContract_EnumITOTriggerType {
    SetITOPrices = 0,
    UpdateStatus = 1,
    UpdateReceiverAddress = 2,
    UpdateMaxAmount = 3,
    UpdateDefaultLimitPerAddress = 4,
    UpdateTimes = 5,
    UpdateWhitelistStatus = 6,
    AddToWhitelist = 7,
    RemoveFromWhitelist = 8,
    UpdateWhitelistTimes = 9,
    UNRECOGNIZED = -1
}
declare function iTOTriggerContract_EnumITOTriggerTypeFromJSON(object: any): ITOTriggerContract_EnumITOTriggerType;
declare function iTOTriggerContract_EnumITOTriggerTypeToJSON(object: ITOTriggerContract_EnumITOTriggerType): number;
declare enum ITOTriggerContract_EnumITOStatus {
    DefaultITO = 0,
    ActiveITO = 1,
    PausedITO = 2,
    UNRECOGNIZED = -1
}
declare function iTOTriggerContract_EnumITOStatusFromJSON(object: any): ITOTriggerContract_EnumITOStatus;
declare function iTOTriggerContract_EnumITOStatusToJSON(object: ITOTriggerContract_EnumITOStatus): number;
declare enum BuyContract_EnumBuyType {
    ITOBuy = 0,
    MarketBuy = 1,
    UNRECOGNIZED = -1
}
declare function buyContract_EnumBuyTypeFromJSON(object: any): BuyContract_EnumBuyType;
declare function buyContract_EnumBuyTypeToJSON(object: BuyContract_EnumBuyType): number;
declare enum SellContract_EnumMarketType {
    BuyItNowMarket = 0,
    AuctionMarket = 1,
    UNRECOGNIZED = -1
}
declare function sellContract_EnumMarketTypeFromJSON(object: any): SellContract_EnumMarketType;
declare function sellContract_EnumMarketTypeToJSON(object: SellContract_EnumMarketType): number;
declare enum AccPermission_AccPermissionType {
    Owner = 0,
    User = 1,
    UNRECOGNIZED = -1
}
declare function accPermission_AccPermissionTypeFromJSON(object: any): AccPermission_AccPermissionType;
declare function accPermission_AccPermissionTypeToJSON(object: AccPermission_AccPermissionType): number;
declare enum DepositContract_EnumDepositType {
    FPRDeposit = 0,
    KDAPool = 1,
    UNRECOGNIZED = -1
}
declare function depositContract_EnumDepositTypeFromJSON(object: any): DepositContract_EnumDepositType;
declare function depositContract_EnumDepositTypeToJSON(object: DepositContract_EnumDepositType): number;
declare enum SmartContract_SCType {
    SCInvoke = 0,
    SCDeploy = 1,
    UNRECOGNIZED = -1
}
declare function smartContract_SCTypeFromJSON(object: any): SmartContract_SCType;
declare function smartContract_SCTypeToJSON(object: SmartContract_SCType): number;
/** TXContract available */
interface TransferContract {
    ToAddress?: Uint8Array | undefined;
    AssetID?: Uint8Array | undefined;
    Amount?: number | undefined;
    KDARoyalties?: number | undefined;
    KLVRoyalties?: number | undefined;
}
declare const TransferContract: MessageFns$1<TransferContract>;
/** CreateAssetContract holds the data for a Klever digital asset */
interface CreateAssetContract {
    Type?: CreateAssetContract_EnumAssetType | undefined;
    Name?: Uint8Array | undefined;
    Ticker?: Uint8Array | undefined;
    OwnerAddress?: Uint8Array | undefined;
    Logo?: string | undefined;
    URIs?: {
        [key: string]: string;
    } | undefined;
    Precision?: number | undefined;
    InitialSupply?: number | undefined;
    MaxSupply?: number | undefined;
    Royalties?: RoyaltiesInfo | undefined;
    Properties?: PropertiesInfo | undefined;
    Attributes?: AttributesInfo | undefined;
    Staking?: StakingInfo | undefined;
    Roles?: RolesInfo[] | undefined;
    AdminAddress?: Uint8Array | undefined;
}
declare const CreateAssetContract: MessageFns$1<CreateAssetContract>;
interface CreateAssetContract_URIsEntry {
    key: string;
    value: string;
}
declare const CreateAssetContract_URIsEntry: MessageFns$1<CreateAssetContract_URIsEntry>;
/** PropertiesInfo hold the properties structure for the KDA asset */
interface PropertiesInfo {
    CanFreeze?: boolean | undefined;
    CanWipe?: boolean | undefined;
    CanPause?: boolean | undefined;
    CanMint?: boolean | undefined;
    CanBurn?: boolean | undefined;
    CanChangeOwner?: boolean | undefined;
    CanAddRoles?: boolean | undefined;
    LimitTransfer?: boolean | undefined;
}
declare const PropertiesInfo: MessageFns$1<PropertiesInfo>;
/** AttributesInfo hold the attributes structure for the KDA asset */
interface AttributesInfo {
    IsPaused?: boolean | undefined;
    IsNFTMintStopped?: boolean | undefined;
    IsRoyaltiesChangeStopped?: boolean | undefined;
    IsNFTMetadataChangeStopped?: boolean | undefined;
}
declare const AttributesInfo: MessageFns$1<AttributesInfo>;
/** StakingInfo hold the staking structure for the KDA asset */
interface StakingInfo {
    Type?: StakingInfo_InterestType | undefined;
    APR?: number | undefined;
    MinEpochsToClaim?: number | undefined;
    MinEpochsToUnstake?: number | undefined;
    MinEpochsToWithdraw?: number | undefined;
}
declare const StakingInfo: MessageFns$1<StakingInfo>;
/** RolesInfo holds the roles for a given asset and the given address */
interface RolesInfo {
    Address?: Uint8Array | undefined;
    HasRoleMint?: boolean | undefined;
    HasRoleSetITOPrices?: boolean | undefined;
    HasRoleDeposit?: boolean | undefined;
    HasRoleTransfer?: boolean | undefined;
}
declare const RolesInfo: MessageFns$1<RolesInfo>;
/** RoyaltiesInfo holds the royalties for a given asset */
interface RoyaltiesInfo {
    Address?: Uint8Array | undefined;
    TransferPercentage?: RoyaltyInfo[] | undefined;
    TransferFixed?: number | undefined;
    MarketPercentage?: number | undefined;
    MarketFixed?: number | undefined;
    SplitRoyalties?: {
        [key: string]: RoyaltySplitInfo;
    } | undefined;
    ITOFixed?: number | undefined;
    ITOPercentage?: number | undefined;
}
declare const RoyaltiesInfo: MessageFns$1<RoyaltiesInfo>;
interface RoyaltiesInfo_SplitRoyaltiesEntry {
    key: string;
    value?: RoyaltySplitInfo | undefined;
}
declare const RoyaltiesInfo_SplitRoyaltiesEntry: MessageFns$1<RoyaltiesInfo_SplitRoyaltiesEntry>;
/** RoyaltySplitInfo holds the royalty split */
interface RoyaltySplitInfo {
    PercentTransferPercentage?: number | undefined;
    PercentTransferFixed?: number | undefined;
    PercentMarketPercentage?: number | undefined;
    PercentMarketFixed?: number | undefined;
    PercentITOPercentage?: number | undefined;
    PercentITOFixed?: number | undefined;
}
declare const RoyaltySplitInfo: MessageFns$1<RoyaltySplitInfo>;
/** RoyaltyInfo holds the royalty threshold */
interface RoyaltyInfo {
    Amount?: number | undefined;
    Percentage?: number | undefined;
}
declare const RoyaltyInfo: MessageFns$1<RoyaltyInfo>;
/** KDAPoolInfo holds the KDA Fee pool info */
interface KDAPoolInfo {
    Active?: boolean | undefined;
    AdminAddress?: Uint8Array | undefined;
    FRatioKDA?: number | undefined;
    FRatioKLV?: number | undefined;
}
declare const KDAPoolInfo: MessageFns$1<KDAPoolInfo>;
/** AssetTriggerContract triggers assets functions */
interface AssetTriggerContract {
    TriggerType?: AssetTriggerContract_EnumTriggerType | undefined;
    AssetID?: Uint8Array | undefined;
    ToAddress?: Uint8Array | undefined;
    Amount?: number | undefined;
    MIME?: Uint8Array | undefined;
    Logo?: string | undefined;
    URIs?: {
        [key: string]: string;
    } | undefined;
    Role?: RolesInfo | undefined;
    Staking?: StakingInfo | undefined;
    Royalties?: RoyaltiesInfo | undefined;
    KDAPool?: KDAPoolInfo | undefined;
    Value?: number | undefined;
}
declare const AssetTriggerContract: MessageFns$1<AssetTriggerContract>;
interface AssetTriggerContract_URIsEntry {
    key: string;
    value: string;
}
declare const AssetTriggerContract_URIsEntry: MessageFns$1<AssetTriggerContract_URIsEntry>;
/** ValidatorConfig holds the data for a validator configuration */
interface ValidatorConfig {
    BLSPublicKey?: Uint8Array | undefined;
    RewardAddress?: Uint8Array | undefined;
    CanDelegate?: boolean | undefined;
    Commission?: number | undefined;
    MaxDelegationAmount?: number | undefined;
    Logo?: string | undefined;
    URIs?: {
        [key: string]: string;
    } | undefined;
    Name?: string | undefined;
}
declare const ValidatorConfig: MessageFns$1<ValidatorConfig>;
interface ValidatorConfig_URIsEntry {
    key: string;
    value: string;
}
declare const ValidatorConfig_URIsEntry: MessageFns$1<ValidatorConfig_URIsEntry>;
/** CreateValidatorContract holds the data for create a validator */
interface CreateValidatorContract {
    OwnerAddress?: Uint8Array | undefined;
    Config?: ValidatorConfig | undefined;
}
declare const CreateValidatorContract: MessageFns$1<CreateValidatorContract>;
/** ValidatorConfigContract holds the data for a validator configuration transaction */
interface ValidatorConfigContract {
    Config?: ValidatorConfig | undefined;
}
declare const ValidatorConfigContract: MessageFns$1<ValidatorConfigContract>;
/** FreezeContract holds the data for a freeze transaction */
interface FreezeContract {
    AssetID?: Uint8Array | undefined;
    Amount?: number | undefined;
}
declare const FreezeContract: MessageFns$1<FreezeContract>;
/** UnfreezeContract holds the data for a unfreeze transaction */
interface UnfreezeContract {
    AssetID?: Uint8Array | undefined;
    BucketID?: Uint8Array | undefined;
}
declare const UnfreezeContract: MessageFns$1<UnfreezeContract>;
/** DelegateContract holds the data for a delegate transaction */
interface DelegateContract {
    ToAddress?: Uint8Array | undefined;
    BucketID?: Uint8Array | undefined;
}
declare const DelegateContract: MessageFns$1<DelegateContract>;
/** UndelegateContract holds the data for a undelegate transaction */
interface UndelegateContract {
    BucketID?: Uint8Array | undefined;
}
declare const UndelegateContract: MessageFns$1<UndelegateContract>;
/** WithdrawContract holds the data for a withdraw transaction */
interface WithdrawContract {
    AssetID?: Uint8Array | undefined;
    WithdrawType?: WithdrawContract_EnumWithdrawType | undefined;
    amount?: number | undefined;
    CurrencyID?: Uint8Array | undefined;
}
declare const WithdrawContract: MessageFns$1<WithdrawContract>;
/** ClaimContract holds the data for a claim transaction */
interface ClaimContract {
    ClaimType?: ClaimContract_EnumClaimType | undefined;
    ID?: Uint8Array | undefined;
}
declare const ClaimContract: MessageFns$1<ClaimContract>;
/** UnjailContract holds the data for a unjail transaction */
interface UnjailContract {
}
declare const UnjailContract: MessageFns$1<UnjailContract>;
/** SetAccountNameContract holds the data for a setAccountName transaction */
interface SetAccountNameContract {
    Name?: Uint8Array | undefined;
}
declare const SetAccountNameContract: MessageFns$1<SetAccountNameContract>;
/** ProposalContract holds the data for a proposal transaction */
interface ProposalContract {
    Parameters?: {
        [key: number]: Uint8Array;
    } | undefined;
    Description?: Uint8Array | undefined;
    EpochsDuration?: number | undefined;
}
declare const ProposalContract: MessageFns$1<ProposalContract>;
interface ProposalContract_ParametersEntry {
    key: number;
    value: Uint8Array;
}
declare const ProposalContract_ParametersEntry: MessageFns$1<ProposalContract_ParametersEntry>;
/** VoteContract holds the data for a vote transaction */
interface VoteContract {
    ProposalID?: number | undefined;
    Amount?: number | undefined;
    Type?: VoteContract_EnumVoteType | undefined;
}
declare const VoteContract: MessageFns$1<VoteContract>;
/** ConfigITOContract holds the data for a ConfigITO transaction */
interface ConfigITOContract {
    AssetID?: Uint8Array | undefined;
    ReceiverAddress?: Uint8Array | undefined;
    Status?: ConfigITOContract_EnumITOStatus | undefined;
    MaxAmount?: number | undefined;
    PackInfo?: {
        [key: string]: PackInfo;
    } | undefined;
    DefaultLimitPerAddress?: number | undefined;
    WhitelistStatus?: ConfigITOContract_EnumITOStatus | undefined;
    WhitelistInfo?: {
        [key: string]: WhitelistInfo;
    } | undefined;
    WhitelistStartTime?: number | undefined;
    WhitelistEndTime?: number | undefined;
    StartTime?: number | undefined;
    EndTime?: number | undefined;
}
declare const ConfigITOContract: MessageFns$1<ConfigITOContract>;
interface ConfigITOContract_PackInfoEntry {
    key: string;
    value?: PackInfo | undefined;
}
declare const ConfigITOContract_PackInfoEntry: MessageFns$1<ConfigITOContract_PackInfoEntry>;
interface ConfigITOContract_WhitelistInfoEntry {
    key: string;
    value?: WhitelistInfo | undefined;
}
declare const ConfigITOContract_WhitelistInfoEntry: MessageFns$1<ConfigITOContract_WhitelistInfoEntry>;
interface WhitelistInfo {
    Limit?: number | undefined;
}
declare const WhitelistInfo: MessageFns$1<WhitelistInfo>;
/** SetITOPrices holds the data for a ConfigITO transaction */
interface SetITOPricesContract {
    AssetID?: Uint8Array | undefined;
    PackInfo?: {
        [key: string]: PackInfo;
    } | undefined;
}
declare const SetITOPricesContract: MessageFns$1<SetITOPricesContract>;
interface SetITOPricesContract_PackInfoEntry {
    key: string;
    value?: PackInfo | undefined;
}
declare const SetITOPricesContract_PackInfoEntry: MessageFns$1<SetITOPricesContract_PackInfoEntry>;
/** ITOTriggerContract triggers assets functions */
interface ITOTriggerContract {
    TriggerType?: ITOTriggerContract_EnumITOTriggerType | undefined;
    AssetID?: Uint8Array | undefined;
    ReceiverAddress?: Uint8Array | undefined;
    Status?: ITOTriggerContract_EnumITOStatus | undefined;
    MaxAmount?: number | undefined;
    PackInfo?: {
        [key: string]: PackInfo;
    } | undefined;
    DefaultLimitPerAddress?: number | undefined;
    WhitelistStatus?: ITOTriggerContract_EnumITOStatus | undefined;
    WhitelistInfo?: {
        [key: string]: WhitelistInfo;
    } | undefined;
    WhitelistStartTime?: number | undefined;
    WhitelistEndTime?: number | undefined;
    StartTime?: number | undefined;
    EndTime?: number | undefined;
}
declare const ITOTriggerContract: MessageFns$1<ITOTriggerContract>;
interface ITOTriggerContract_PackInfoEntry {
    key: string;
    value?: PackInfo | undefined;
}
declare const ITOTriggerContract_PackInfoEntry: MessageFns$1<ITOTriggerContract_PackInfoEntry>;
interface ITOTriggerContract_WhitelistInfoEntry {
    key: string;
    value?: WhitelistInfo | undefined;
}
declare const ITOTriggerContract_WhitelistInfoEntry: MessageFns$1<ITOTriggerContract_WhitelistInfoEntry>;
/** PackInfo holds the pack list structure for the ITO contract */
interface PackInfo {
    Packs?: PackItem[] | undefined;
}
declare const PackInfo: MessageFns$1<PackInfo>;
/** PackItem hold the pack structure for the ITO contract */
interface PackItem {
    Amount?: number | undefined;
    Price?: number | undefined;
}
declare const PackItem: MessageFns$1<PackItem>;
/** BuyContract holds the data for a buy transaction */
interface BuyContract {
    BuyType?: BuyContract_EnumBuyType | undefined;
    ID?: Uint8Array | undefined;
    CurrencyID?: Uint8Array | undefined;
    Amount?: number | undefined;
    CurrencyAmount?: number | undefined;
}
declare const BuyContract: MessageFns$1<BuyContract>;
/** SellContract holds the data for a sell transaction */
interface SellContract {
    MarketType?: SellContract_EnumMarketType | undefined;
    MarketplaceID?: Uint8Array | undefined;
    AssetID?: Uint8Array | undefined;
    CurrencyID?: Uint8Array | undefined;
    Price?: number | undefined;
    ReservePrice?: number | undefined;
    EndTime?: number | undefined;
}
declare const SellContract: MessageFns$1<SellContract>;
/** CancelMarketOrderContract holds the data for a cancel market transaction */
interface CancelMarketOrderContract {
    OrderID?: Uint8Array | undefined;
}
declare const CancelMarketOrderContract: MessageFns$1<CancelMarketOrderContract>;
/** CreateMarketplaceContract holds the data for a create marketplace transaction */
interface CreateMarketplaceContract {
    Name?: Uint8Array | undefined;
    ReferralAddress?: Uint8Array | undefined;
    ReferralPercentage?: number | undefined;
}
declare const CreateMarketplaceContract: MessageFns$1<CreateMarketplaceContract>;
/** ConfigMarketplaceContract holds the data for a config marketplace transaction */
interface ConfigMarketplaceContract {
    MarketplaceID?: Uint8Array | undefined;
    Name?: Uint8Array | undefined;
    ReferralAddress?: Uint8Array | undefined;
    ReferralPercentage?: number | undefined;
}
declare const ConfigMarketplaceContract: MessageFns$1<ConfigMarketplaceContract>;
interface AccKey {
    address?: Uint8Array | undefined;
    weight?: number | undefined;
}
declare const AccKey: MessageFns$1<AccKey>;
interface AccPermission {
    Type?: AccPermission_AccPermissionType | undefined;
    PermissionName?: string | undefined;
    Threshold?: number | undefined;
    /** 1 bit 1 contract */
    Operations?: Uint8Array | undefined;
    Signers?: AccKey[] | undefined;
}
declare const AccPermission: MessageFns$1<AccPermission>;
/** UpdateAccountPermissionContract holds the data for update account permission transaction */
interface UpdateAccountPermissionContract {
    Permissions?: AccPermission[] | undefined;
}
declare const UpdateAccountPermissionContract: MessageFns$1<UpdateAccountPermissionContract>;
/** DepositContract holds the data for a deposit transaction */
interface DepositContract {
    DepositType?: DepositContract_EnumDepositType | undefined;
    ID?: Uint8Array | undefined;
    CurrencyID?: Uint8Array | undefined;
    Amount?: number | undefined;
}
declare const DepositContract: MessageFns$1<DepositContract>;
interface CallValue {
    Amount?: number | undefined;
    KDARoyalties?: number | undefined;
    KLVRoyalties?: number | undefined;
}
declare const CallValue: MessageFns$1<CallValue>;
interface SmartContract {
    Type?: SmartContract_SCType | undefined;
    Address?: Uint8Array | undefined;
    /**
     * SmartContract CallValue is represented by a map of currencyID and amount
     *  should be limited to 50 currencies
     */
    CallValue?: {
        [key: string]: CallValue;
    } | undefined;
}
declare const SmartContract: MessageFns$1<SmartContract>;
interface SmartContract_CallValueEntry {
    key: string;
    value?: CallValue | undefined;
}
declare const SmartContract_CallValueEntry: MessageFns$1<SmartContract_CallValueEntry>;
type ProtoMetaMessageOptions = {
    options?: {
        [key: string]: any;
    };
    fields?: {
        [key: string]: {
            [key: string]: any;
        };
    };
    oneof?: {
        [key: string]: {
            [key: string]: any;
        };
    };
    nested?: {
        [key: string]: ProtoMetaMessageOptions;
    };
};
interface ProtoMetadata {
    fileDescriptor: FileDescriptorProto;
    references: {
        [key: string]: any;
    };
    dependencies?: ProtoMetadata[];
    options?: {
        options?: {
            [key: string]: any;
        };
        services?: {
            [key: string]: {
                options?: {
                    [key: string]: any;
                };
                methods?: {
                    [key: string]: {
                        [key: string]: any;
                    };
                };
            };
        };
        messages?: {
            [key: string]: ProtoMetaMessageOptions;
        };
        enums?: {
            [key: string]: {
                options?: {
                    [key: string]: any;
                };
                values?: {
                    [key: string]: {
                        [key: string]: any;
                    };
                };
            };
        };
    };
}
declare const protoMetadata: ProtoMetadata;
type Builtin$1 = Date | Function | Uint8Array | string | number | boolean | undefined;
type DeepPartial$1<T> = T extends Builtin$1 ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial$1<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial$1<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial$1<T[K]>;
} : Partial<T>;
type KeysOfUnion$1<T> = T extends T ? keyof T : never;
type Exact$1<P, I extends P> = P extends Builtin$1 ? P : P & {
    [K in keyof P]: Exact$1<P[K], I[K]>;
} & {
    [K in Exclude<keyof I, KeysOfUnion$1<P>>]: never;
};
interface MessageFns$1<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter;
    decode(input: BinaryReader | Uint8Array, length?: number): T;
    fromJSON(object: any): T;
    toJSON(message: T): unknown;
    create<I extends Exact$1<DeepPartial$1<T>, I>>(base?: I): T;
    fromPartial<I extends Exact$1<DeepPartial$1<T>, I>>(object: I): T;
}

declare const contracts_d_protobufPackage: typeof protobufPackage;
declare const contracts_d_TransferContract: typeof TransferContract;
declare const contracts_d_CreateAssetContract: typeof CreateAssetContract;
type contracts_d_CreateAssetContract_EnumAssetType = CreateAssetContract_EnumAssetType;
declare const contracts_d_CreateAssetContract_EnumAssetType: typeof CreateAssetContract_EnumAssetType;
declare const contracts_d_createAssetContract_EnumAssetTypeFromJSON: typeof createAssetContract_EnumAssetTypeFromJSON;
declare const contracts_d_createAssetContract_EnumAssetTypeToJSON: typeof createAssetContract_EnumAssetTypeToJSON;
declare const contracts_d_CreateAssetContract_URIsEntry: typeof CreateAssetContract_URIsEntry;
declare const contracts_d_PropertiesInfo: typeof PropertiesInfo;
declare const contracts_d_AttributesInfo: typeof AttributesInfo;
declare const contracts_d_StakingInfo: typeof StakingInfo;
type contracts_d_StakingInfo_InterestType = StakingInfo_InterestType;
declare const contracts_d_StakingInfo_InterestType: typeof StakingInfo_InterestType;
declare const contracts_d_stakingInfo_InterestTypeFromJSON: typeof stakingInfo_InterestTypeFromJSON;
declare const contracts_d_stakingInfo_InterestTypeToJSON: typeof stakingInfo_InterestTypeToJSON;
declare const contracts_d_RolesInfo: typeof RolesInfo;
declare const contracts_d_RoyaltiesInfo: typeof RoyaltiesInfo;
declare const contracts_d_RoyaltiesInfo_SplitRoyaltiesEntry: typeof RoyaltiesInfo_SplitRoyaltiesEntry;
declare const contracts_d_RoyaltySplitInfo: typeof RoyaltySplitInfo;
declare const contracts_d_RoyaltyInfo: typeof RoyaltyInfo;
declare const contracts_d_KDAPoolInfo: typeof KDAPoolInfo;
declare const contracts_d_AssetTriggerContract: typeof AssetTriggerContract;
type contracts_d_AssetTriggerContract_EnumTriggerType = AssetTriggerContract_EnumTriggerType;
declare const contracts_d_AssetTriggerContract_EnumTriggerType: typeof AssetTriggerContract_EnumTriggerType;
declare const contracts_d_assetTriggerContract_EnumTriggerTypeFromJSON: typeof assetTriggerContract_EnumTriggerTypeFromJSON;
declare const contracts_d_assetTriggerContract_EnumTriggerTypeToJSON: typeof assetTriggerContract_EnumTriggerTypeToJSON;
declare const contracts_d_AssetTriggerContract_URIsEntry: typeof AssetTriggerContract_URIsEntry;
declare const contracts_d_ValidatorConfig: typeof ValidatorConfig;
declare const contracts_d_ValidatorConfig_URIsEntry: typeof ValidatorConfig_URIsEntry;
declare const contracts_d_CreateValidatorContract: typeof CreateValidatorContract;
declare const contracts_d_ValidatorConfigContract: typeof ValidatorConfigContract;
declare const contracts_d_FreezeContract: typeof FreezeContract;
declare const contracts_d_UnfreezeContract: typeof UnfreezeContract;
declare const contracts_d_DelegateContract: typeof DelegateContract;
declare const contracts_d_UndelegateContract: typeof UndelegateContract;
declare const contracts_d_WithdrawContract: typeof WithdrawContract;
type contracts_d_WithdrawContract_EnumWithdrawType = WithdrawContract_EnumWithdrawType;
declare const contracts_d_WithdrawContract_EnumWithdrawType: typeof WithdrawContract_EnumWithdrawType;
declare const contracts_d_withdrawContract_EnumWithdrawTypeFromJSON: typeof withdrawContract_EnumWithdrawTypeFromJSON;
declare const contracts_d_withdrawContract_EnumWithdrawTypeToJSON: typeof withdrawContract_EnumWithdrawTypeToJSON;
declare const contracts_d_ClaimContract: typeof ClaimContract;
type contracts_d_ClaimContract_EnumClaimType = ClaimContract_EnumClaimType;
declare const contracts_d_ClaimContract_EnumClaimType: typeof ClaimContract_EnumClaimType;
declare const contracts_d_claimContract_EnumClaimTypeFromJSON: typeof claimContract_EnumClaimTypeFromJSON;
declare const contracts_d_claimContract_EnumClaimTypeToJSON: typeof claimContract_EnumClaimTypeToJSON;
declare const contracts_d_UnjailContract: typeof UnjailContract;
declare const contracts_d_SetAccountNameContract: typeof SetAccountNameContract;
declare const contracts_d_ProposalContract: typeof ProposalContract;
declare const contracts_d_ProposalContract_ParametersEntry: typeof ProposalContract_ParametersEntry;
declare const contracts_d_VoteContract: typeof VoteContract;
type contracts_d_VoteContract_EnumVoteType = VoteContract_EnumVoteType;
declare const contracts_d_VoteContract_EnumVoteType: typeof VoteContract_EnumVoteType;
declare const contracts_d_voteContract_EnumVoteTypeFromJSON: typeof voteContract_EnumVoteTypeFromJSON;
declare const contracts_d_voteContract_EnumVoteTypeToJSON: typeof voteContract_EnumVoteTypeToJSON;
declare const contracts_d_ConfigITOContract: typeof ConfigITOContract;
type contracts_d_ConfigITOContract_EnumITOStatus = ConfigITOContract_EnumITOStatus;
declare const contracts_d_ConfigITOContract_EnumITOStatus: typeof ConfigITOContract_EnumITOStatus;
declare const contracts_d_configITOContract_EnumITOStatusFromJSON: typeof configITOContract_EnumITOStatusFromJSON;
declare const contracts_d_configITOContract_EnumITOStatusToJSON: typeof configITOContract_EnumITOStatusToJSON;
declare const contracts_d_ConfigITOContract_PackInfoEntry: typeof ConfigITOContract_PackInfoEntry;
declare const contracts_d_ConfigITOContract_WhitelistInfoEntry: typeof ConfigITOContract_WhitelistInfoEntry;
declare const contracts_d_WhitelistInfo: typeof WhitelistInfo;
declare const contracts_d_SetITOPricesContract: typeof SetITOPricesContract;
declare const contracts_d_SetITOPricesContract_PackInfoEntry: typeof SetITOPricesContract_PackInfoEntry;
declare const contracts_d_ITOTriggerContract: typeof ITOTriggerContract;
type contracts_d_ITOTriggerContract_EnumITOTriggerType = ITOTriggerContract_EnumITOTriggerType;
declare const contracts_d_ITOTriggerContract_EnumITOTriggerType: typeof ITOTriggerContract_EnumITOTriggerType;
declare const contracts_d_iTOTriggerContract_EnumITOTriggerTypeFromJSON: typeof iTOTriggerContract_EnumITOTriggerTypeFromJSON;
declare const contracts_d_iTOTriggerContract_EnumITOTriggerTypeToJSON: typeof iTOTriggerContract_EnumITOTriggerTypeToJSON;
type contracts_d_ITOTriggerContract_EnumITOStatus = ITOTriggerContract_EnumITOStatus;
declare const contracts_d_ITOTriggerContract_EnumITOStatus: typeof ITOTriggerContract_EnumITOStatus;
declare const contracts_d_iTOTriggerContract_EnumITOStatusFromJSON: typeof iTOTriggerContract_EnumITOStatusFromJSON;
declare const contracts_d_iTOTriggerContract_EnumITOStatusToJSON: typeof iTOTriggerContract_EnumITOStatusToJSON;
declare const contracts_d_ITOTriggerContract_PackInfoEntry: typeof ITOTriggerContract_PackInfoEntry;
declare const contracts_d_ITOTriggerContract_WhitelistInfoEntry: typeof ITOTriggerContract_WhitelistInfoEntry;
declare const contracts_d_PackInfo: typeof PackInfo;
declare const contracts_d_PackItem: typeof PackItem;
declare const contracts_d_BuyContract: typeof BuyContract;
type contracts_d_BuyContract_EnumBuyType = BuyContract_EnumBuyType;
declare const contracts_d_BuyContract_EnumBuyType: typeof BuyContract_EnumBuyType;
declare const contracts_d_buyContract_EnumBuyTypeFromJSON: typeof buyContract_EnumBuyTypeFromJSON;
declare const contracts_d_buyContract_EnumBuyTypeToJSON: typeof buyContract_EnumBuyTypeToJSON;
declare const contracts_d_SellContract: typeof SellContract;
type contracts_d_SellContract_EnumMarketType = SellContract_EnumMarketType;
declare const contracts_d_SellContract_EnumMarketType: typeof SellContract_EnumMarketType;
declare const contracts_d_sellContract_EnumMarketTypeFromJSON: typeof sellContract_EnumMarketTypeFromJSON;
declare const contracts_d_sellContract_EnumMarketTypeToJSON: typeof sellContract_EnumMarketTypeToJSON;
declare const contracts_d_CancelMarketOrderContract: typeof CancelMarketOrderContract;
declare const contracts_d_CreateMarketplaceContract: typeof CreateMarketplaceContract;
declare const contracts_d_ConfigMarketplaceContract: typeof ConfigMarketplaceContract;
declare const contracts_d_AccKey: typeof AccKey;
declare const contracts_d_AccPermission: typeof AccPermission;
type contracts_d_AccPermission_AccPermissionType = AccPermission_AccPermissionType;
declare const contracts_d_AccPermission_AccPermissionType: typeof AccPermission_AccPermissionType;
declare const contracts_d_accPermission_AccPermissionTypeFromJSON: typeof accPermission_AccPermissionTypeFromJSON;
declare const contracts_d_accPermission_AccPermissionTypeToJSON: typeof accPermission_AccPermissionTypeToJSON;
declare const contracts_d_UpdateAccountPermissionContract: typeof UpdateAccountPermissionContract;
declare const contracts_d_DepositContract: typeof DepositContract;
type contracts_d_DepositContract_EnumDepositType = DepositContract_EnumDepositType;
declare const contracts_d_DepositContract_EnumDepositType: typeof DepositContract_EnumDepositType;
declare const contracts_d_depositContract_EnumDepositTypeFromJSON: typeof depositContract_EnumDepositTypeFromJSON;
declare const contracts_d_depositContract_EnumDepositTypeToJSON: typeof depositContract_EnumDepositTypeToJSON;
declare const contracts_d_CallValue: typeof CallValue;
declare const contracts_d_SmartContract: typeof SmartContract;
type contracts_d_SmartContract_SCType = SmartContract_SCType;
declare const contracts_d_SmartContract_SCType: typeof SmartContract_SCType;
declare const contracts_d_smartContract_SCTypeFromJSON: typeof smartContract_SCTypeFromJSON;
declare const contracts_d_smartContract_SCTypeToJSON: typeof smartContract_SCTypeToJSON;
declare const contracts_d_SmartContract_CallValueEntry: typeof SmartContract_CallValueEntry;
type contracts_d_ProtoMetadata = ProtoMetadata;
declare const contracts_d_protoMetadata: typeof protoMetadata;
declare namespace contracts_d {
  export {
    contracts_d_protobufPackage as protobufPackage,
    contracts_d_TransferContract as TransferContract,
    contracts_d_CreateAssetContract as CreateAssetContract,
    contracts_d_CreateAssetContract_EnumAssetType as CreateAssetContract_EnumAssetType,
    contracts_d_createAssetContract_EnumAssetTypeFromJSON as createAssetContract_EnumAssetTypeFromJSON,
    contracts_d_createAssetContract_EnumAssetTypeToJSON as createAssetContract_EnumAssetTypeToJSON,
    contracts_d_CreateAssetContract_URIsEntry as CreateAssetContract_URIsEntry,
    contracts_d_PropertiesInfo as PropertiesInfo,
    contracts_d_AttributesInfo as AttributesInfo,
    contracts_d_StakingInfo as StakingInfo,
    contracts_d_StakingInfo_InterestType as StakingInfo_InterestType,
    contracts_d_stakingInfo_InterestTypeFromJSON as stakingInfo_InterestTypeFromJSON,
    contracts_d_stakingInfo_InterestTypeToJSON as stakingInfo_InterestTypeToJSON,
    contracts_d_RolesInfo as RolesInfo,
    contracts_d_RoyaltiesInfo as RoyaltiesInfo,
    contracts_d_RoyaltiesInfo_SplitRoyaltiesEntry as RoyaltiesInfo_SplitRoyaltiesEntry,
    contracts_d_RoyaltySplitInfo as RoyaltySplitInfo,
    contracts_d_RoyaltyInfo as RoyaltyInfo,
    contracts_d_KDAPoolInfo as KDAPoolInfo,
    contracts_d_AssetTriggerContract as AssetTriggerContract,
    contracts_d_AssetTriggerContract_EnumTriggerType as AssetTriggerContract_EnumTriggerType,
    contracts_d_assetTriggerContract_EnumTriggerTypeFromJSON as assetTriggerContract_EnumTriggerTypeFromJSON,
    contracts_d_assetTriggerContract_EnumTriggerTypeToJSON as assetTriggerContract_EnumTriggerTypeToJSON,
    contracts_d_AssetTriggerContract_URIsEntry as AssetTriggerContract_URIsEntry,
    contracts_d_ValidatorConfig as ValidatorConfig,
    contracts_d_ValidatorConfig_URIsEntry as ValidatorConfig_URIsEntry,
    contracts_d_CreateValidatorContract as CreateValidatorContract,
    contracts_d_ValidatorConfigContract as ValidatorConfigContract,
    contracts_d_FreezeContract as FreezeContract,
    contracts_d_UnfreezeContract as UnfreezeContract,
    contracts_d_DelegateContract as DelegateContract,
    contracts_d_UndelegateContract as UndelegateContract,
    contracts_d_WithdrawContract as WithdrawContract,
    contracts_d_WithdrawContract_EnumWithdrawType as WithdrawContract_EnumWithdrawType,
    contracts_d_withdrawContract_EnumWithdrawTypeFromJSON as withdrawContract_EnumWithdrawTypeFromJSON,
    contracts_d_withdrawContract_EnumWithdrawTypeToJSON as withdrawContract_EnumWithdrawTypeToJSON,
    contracts_d_ClaimContract as ClaimContract,
    contracts_d_ClaimContract_EnumClaimType as ClaimContract_EnumClaimType,
    contracts_d_claimContract_EnumClaimTypeFromJSON as claimContract_EnumClaimTypeFromJSON,
    contracts_d_claimContract_EnumClaimTypeToJSON as claimContract_EnumClaimTypeToJSON,
    contracts_d_UnjailContract as UnjailContract,
    contracts_d_SetAccountNameContract as SetAccountNameContract,
    contracts_d_ProposalContract as ProposalContract,
    contracts_d_ProposalContract_ParametersEntry as ProposalContract_ParametersEntry,
    contracts_d_VoteContract as VoteContract,
    contracts_d_VoteContract_EnumVoteType as VoteContract_EnumVoteType,
    contracts_d_voteContract_EnumVoteTypeFromJSON as voteContract_EnumVoteTypeFromJSON,
    contracts_d_voteContract_EnumVoteTypeToJSON as voteContract_EnumVoteTypeToJSON,
    contracts_d_ConfigITOContract as ConfigITOContract,
    contracts_d_ConfigITOContract_EnumITOStatus as ConfigITOContract_EnumITOStatus,
    contracts_d_configITOContract_EnumITOStatusFromJSON as configITOContract_EnumITOStatusFromJSON,
    contracts_d_configITOContract_EnumITOStatusToJSON as configITOContract_EnumITOStatusToJSON,
    contracts_d_ConfigITOContract_PackInfoEntry as ConfigITOContract_PackInfoEntry,
    contracts_d_ConfigITOContract_WhitelistInfoEntry as ConfigITOContract_WhitelistInfoEntry,
    contracts_d_WhitelistInfo as WhitelistInfo,
    contracts_d_SetITOPricesContract as SetITOPricesContract,
    contracts_d_SetITOPricesContract_PackInfoEntry as SetITOPricesContract_PackInfoEntry,
    contracts_d_ITOTriggerContract as ITOTriggerContract,
    contracts_d_ITOTriggerContract_EnumITOTriggerType as ITOTriggerContract_EnumITOTriggerType,
    contracts_d_iTOTriggerContract_EnumITOTriggerTypeFromJSON as iTOTriggerContract_EnumITOTriggerTypeFromJSON,
    contracts_d_iTOTriggerContract_EnumITOTriggerTypeToJSON as iTOTriggerContract_EnumITOTriggerTypeToJSON,
    contracts_d_ITOTriggerContract_EnumITOStatus as ITOTriggerContract_EnumITOStatus,
    contracts_d_iTOTriggerContract_EnumITOStatusFromJSON as iTOTriggerContract_EnumITOStatusFromJSON,
    contracts_d_iTOTriggerContract_EnumITOStatusToJSON as iTOTriggerContract_EnumITOStatusToJSON,
    contracts_d_ITOTriggerContract_PackInfoEntry as ITOTriggerContract_PackInfoEntry,
    contracts_d_ITOTriggerContract_WhitelistInfoEntry as ITOTriggerContract_WhitelistInfoEntry,
    contracts_d_PackInfo as PackInfo,
    contracts_d_PackItem as PackItem,
    contracts_d_BuyContract as BuyContract,
    contracts_d_BuyContract_EnumBuyType as BuyContract_EnumBuyType,
    contracts_d_buyContract_EnumBuyTypeFromJSON as buyContract_EnumBuyTypeFromJSON,
    contracts_d_buyContract_EnumBuyTypeToJSON as buyContract_EnumBuyTypeToJSON,
    contracts_d_SellContract as SellContract,
    contracts_d_SellContract_EnumMarketType as SellContract_EnumMarketType,
    contracts_d_sellContract_EnumMarketTypeFromJSON as sellContract_EnumMarketTypeFromJSON,
    contracts_d_sellContract_EnumMarketTypeToJSON as sellContract_EnumMarketTypeToJSON,
    contracts_d_CancelMarketOrderContract as CancelMarketOrderContract,
    contracts_d_CreateMarketplaceContract as CreateMarketplaceContract,
    contracts_d_ConfigMarketplaceContract as ConfigMarketplaceContract,
    contracts_d_AccKey as AccKey,
    contracts_d_AccPermission as AccPermission,
    contracts_d_AccPermission_AccPermissionType as AccPermission_AccPermissionType,
    contracts_d_accPermission_AccPermissionTypeFromJSON as accPermission_AccPermissionTypeFromJSON,
    contracts_d_accPermission_AccPermissionTypeToJSON as accPermission_AccPermissionTypeToJSON,
    contracts_d_UpdateAccountPermissionContract as UpdateAccountPermissionContract,
    contracts_d_DepositContract as DepositContract,
    contracts_d_DepositContract_EnumDepositType as DepositContract_EnumDepositType,
    contracts_d_depositContract_EnumDepositTypeFromJSON as depositContract_EnumDepositTypeFromJSON,
    contracts_d_depositContract_EnumDepositTypeToJSON as depositContract_EnumDepositTypeToJSON,
    contracts_d_CallValue as CallValue,
    contracts_d_SmartContract as SmartContract,
    contracts_d_SmartContract_SCType as SmartContract_SCType,
    contracts_d_smartContract_SCTypeFromJSON as smartContract_SCTypeFromJSON,
    contracts_d_smartContract_SCTypeToJSON as smartContract_SCTypeToJSON,
    contracts_d_SmartContract_CallValueEntry as SmartContract_CallValueEntry,
    contracts_d_ProtoMetadata as ProtoMetadata,
    contracts_d_protoMetadata as protoMetadata,
    DeepPartial$1 as DeepPartial,
    Exact$1 as Exact,
    MessageFns$1 as MessageFns,
  };
}

declare enum TXContract_ContractType {
    TransferContractType = 0,
    CreateAssetContractType = 1,
    CreateValidatorContractType = 2,
    ValidatorConfigContractType = 3,
    FreezeContractType = 4,
    UnfreezeContractType = 5,
    DelegateContractType = 6,
    UndelegateContractType = 7,
    WithdrawContractType = 8,
    ClaimContractType = 9,
    UnjailContractType = 10,
    AssetTriggerContractType = 11,
    SetAccountNameContractType = 12,
    ProposalContractType = 13,
    VoteContractType = 14,
    ConfigITOContractType = 15,
    SetITOPricesContractType = 16,
    BuyContractType = 17,
    SellContractType = 18,
    CancelMarketOrderContractType = 19,
    CreateMarketplaceContractType = 20,
    ConfigMarketplaceContractType = 21,
    UpdateAccountPermissionContractType = 22,
    DepositContractType = 23,
    ITOTriggerContractType = 24,
    SmartContractType = 63,
    UNRECOGNIZED = -1
}
declare enum Transaction_TXResult {
    SUCCESS = 0,
    FAILED = 1,
    UNRECOGNIZED = -1
}
declare enum Transaction_TXResultCode {
    Ok = 0,
    /** OutOfFunds - OutOfFunds is returned when the caller (sender) runs out of funds. */
    OutOfFunds = 1,
    AccountError = 2,
    AssetError = 3,
    ContractInvalid = 4,
    /** ContractNotFound - ContractNotFound is returned when the called contract does not exist. */
    ContractNotFound = 5,
    FeeInvalid = 6,
    ParameterInvalid = 7,
    APRInvalid = 8,
    AssetIDInvalid = 9,
    AssetTypeInvalid = 10,
    AssetCantBeMinted = 11,
    AssetCantBeBurned = 12,
    AssetCantBePaused = 13,
    AssetCantBeDelegated = 14,
    AssetOwnerCantBeChanged = 15,
    AccountNotOwner = 16,
    CommissionTooHigh = 17,
    DelegationAmountInvalid = 18,
    ProposalNotActive = 19,
    ValueInvalid = 20,
    AmountInvalid = 21,
    BucketIDInvalid = 22,
    KeyConflict = 23,
    MaxDelegationAmount = 24,
    InvalidPeerKey = 25,
    MinKFIStakedUnreached = 26,
    MaxSupplyExceeded = 27,
    SaveAccountError = 28,
    LoadAccountError = 29,
    SameAccountError = 30,
    AssetPaused = 31,
    DeletegateError = 32,
    WithdrawNotAvailable = 33,
    ErrOverflow = 34,
    SetStakingErr = 35,
    SetMarketOrderErr = 36,
    BalanceError = 37,
    KAPPError = 38,
    UnfreezeError = 39,
    UndelegateError = 40,
    WithdrawError = 41,
    ClaimError = 42,
    BucketsExceeded = 43,
    AssetCantBeWiped = 44,
    AssetCantAddRoles = 45,
    FreezeError = 46,
    ITONotActive = 47,
    NFTMintStopped = 48,
    RoyaltiesChangeStopped = 49,
    ITOKAPPError = 50,
    ITOWhiteListError = 51,
    NFTMetadataChangeStopped = 52,
    AlreadyExists = 53,
    IteratorLimitReached = 54,
    /** VMFunctionNotFound - FunctionNotFound is returned when the input specifies a function name that does not exist or is not public. */
    VMFunctionNotFound = 55,
    /** VMFunctionWrongSignature - FunctionWrongSignature is returned when the wrong number of arguments is provided. */
    VMFunctionWrongSignature = 56,
    /** VMUserError - UserError is returned for various execution errors. */
    VMUserError = 57,
    /** VMOutOfGas - OutOfGas is returned when VM execution runs out of gas. */
    VMOutOfGas = 58,
    /** VMAccountCollision - AccountCollision is returned when created account already exists. */
    VMAccountCollision = 59,
    /** VMCallStackOverFlow - CallStackOverFlow is returned when stack overflow occurs. */
    VMCallStackOverFlow = 60,
    /** VMExecutionPanicked - Execution Panicked */
    VMExecutionPanicked = 61,
    /** VMExecutionFailed - ExecutionFailed is returned when the execution of the specified function has failed. */
    VMExecutionFailed = 62,
    /** VMUpgradeFailed - UpgradeFailed is returned when the upgrade of the contract has failed */
    VMUpgradeFailed = 63,
    /** VMSimulateFailed - SimulateFailed is returned when tx simulation fails execution */
    VMSimulateFailed = 64,
    /** KDATransferNotAllowed - KDA Transfer not allowed */
    KDATransferNotAllowed = 65,
    Fail = 99,
    UNRECOGNIZED = -1
}
/** TXContract available */
interface TXContract {
    Type?: TXContract_ContractType | undefined;
    Parameter?: Any | undefined;
}
declare const TXContract: MessageFns<TXContract>;
/** Transaction holds all the data needed for a value transfer */
interface Transaction$1 {
    RawData?: Transaction_Raw | undefined;
    Signature?: Uint8Array[] | undefined;
    Result?: Transaction_TXResult | undefined;
    ResultCode?: Transaction_TXResultCode | undefined;
    Receipts?: Transaction_Receipt[] | undefined;
    Block?: number | undefined;
    GasLimit?: number | undefined;
    GasMultiplier?: number | undefined;
}
declare const Transaction$1: MessageFns<Transaction$1>;
interface Transaction_KDAFee {
    KDA?: Uint8Array | undefined;
    /** TODO: allow spread */
    Amount?: number | undefined;
}
declare const Transaction_KDAFee: MessageFns<Transaction_KDAFee>;
interface Transaction_Raw {
    Nonce?: number | undefined;
    Sender?: Uint8Array | undefined;
    Contract?: TXContract[] | undefined;
    PermissionID?: number | undefined;
    Data?: Uint8Array[] | undefined;
    KAppFee?: number | undefined;
    BandwidthFee?: number | undefined;
    Version?: number | undefined;
    ChainID?: Uint8Array | undefined;
    KDAFee?: Transaction_KDAFee | undefined;
}
declare const Transaction_Raw: MessageFns<Transaction_Raw>;
interface Transaction_Receipt {
    Data?: Uint8Array[] | undefined;
}
declare const Transaction_Receipt: MessageFns<Transaction_Receipt>;
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & {
    [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
};
interface MessageFns<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter;
    decode(input: BinaryReader | Uint8Array, length?: number): T;
    fromJSON(object: any): T;
    toJSON(message: T): unknown;
    create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
    fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}

declare class Transaction {
    data: Transaction$1;
    constructor(data?: any[] | {
        Nonce?: number;
        Sender?: Uint8Array;
        Contract?: TXContract[];
        PermissionID?: number;
        Data?: Uint8Array[];
        KAppFee?: number;
        BandwidthFee?: number;
        Version?: number;
        ChainID?: Uint8Array;
    });
    addContract: (type: TXContract_ContractType, contract: any) => Promise<void>;
    signMessage: (message: string, privateKey: string) => Promise<Uint8Array>;
    computeHash: () => string;
    sign: (privateKey: string) => Promise<Boolean>;
    hex: () => string;
    fromHex: (hex: string) => void;
    toJSON: () => string;
    decode: () => string;
    toBroadcast: () => any;
}

declare const abiDecoder: {
    decodeValue: (hexValue: string, type: string) => any;
    decodeList: (hexValue: string, type: string, abi: string) => any;
    decodeStruct: (hexValue: string, type: string, abi: string) => any;
};

type ABITypeJSON = {
    types: {
        [key: string]: {
            type: string;
            fields: {
                name: string;
                type: string;
            }[];
        };
    };
};

declare function twosComplement(value: number, bitsSize: number, isNested?: boolean): string;
declare function encodeBigNumber(value: number, isNested?: boolean): string;
declare function encodeLengthPlusData(value: string | any[], innerType: string, isNested?: boolean): string | string[];
declare function toByteArray(str: string): number[];
declare function encodeAddress(value: string): string;
declare const abiEncoder: {
    encodeABIValue: (value: any, type: string, isNested?: boolean) => string;
    encodeWithABI: (abi: ABITypeJSON, value: any, type: string) => string;
    encodeLengthPlusData: typeof encodeLengthPlusData;
    toByteArray: typeof toByteArray;
    encodeBigNumber: typeof encodeBigNumber;
    twosComplement: typeof twosComplement;
    encodeAddress: typeof encodeAddress;
};

export { Account, contracts_d as Contracts, IAccountResponse, TXContract_ContractType, Transaction, abiDecoder, abiEncoder, any_d as proto, utils };
