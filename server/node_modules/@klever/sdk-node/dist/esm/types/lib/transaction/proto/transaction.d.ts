import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { FileDescriptorProto } from "ts-proto-descriptors";
import { Any } from "./google/protobuf/any";
export declare const protobufPackage = "proto";
/** TXContract available */
export interface TXContract {
    Type?: TXContract_ContractType | undefined;
    Parameter?: Any | undefined;
}
export declare enum TXContract_ContractType {
    TransferContractType = 0,
    CreateAssetContractType = 1,
    CreateValidatorContractType = 2,
    ValidatorConfigContractType = 3,
    FreezeContractType = 4,
    UnfreezeContractType = 5,
    DelegateContractType = 6,
    UndelegateContractType = 7,
    WithdrawContractType = 8,
    ClaimContractType = 9,
    UnjailContractType = 10,
    AssetTriggerContractType = 11,
    SetAccountNameContractType = 12,
    ProposalContractType = 13,
    VoteContractType = 14,
    ConfigITOContractType = 15,
    SetITOPricesContractType = 16,
    BuyContractType = 17,
    SellContractType = 18,
    CancelMarketOrderContractType = 19,
    CreateMarketplaceContractType = 20,
    ConfigMarketplaceContractType = 21,
    UpdateAccountPermissionContractType = 22,
    DepositContractType = 23,
    ITOTriggerContractType = 24,
    SmartContractType = 63,
    UNRECOGNIZED = -1
}
export declare function tXContract_ContractTypeFromJSON(object: any): TXContract_ContractType;
export declare function tXContract_ContractTypeToJSON(object: TXContract_ContractType): number;
/** Transaction holds all the data needed for a value transfer */
export interface Transaction {
    RawData?: Transaction_Raw | undefined;
    Signature?: Uint8Array[] | undefined;
    Result?: Transaction_TXResult | undefined;
    ResultCode?: Transaction_TXResultCode | undefined;
    Receipts?: Transaction_Receipt[] | undefined;
    Block?: number | undefined;
    GasLimit?: number | undefined;
    GasMultiplier?: number | undefined;
}
export declare enum Transaction_TXResult {
    SUCCESS = 0,
    FAILED = 1,
    UNRECOGNIZED = -1
}
export declare function transaction_TXResultFromJSON(object: any): Transaction_TXResult;
export declare function transaction_TXResultToJSON(object: Transaction_TXResult): number;
export declare enum Transaction_TXResultCode {
    Ok = 0,
    /** OutOfFunds - OutOfFunds is returned when the caller (sender) runs out of funds. */
    OutOfFunds = 1,
    AccountError = 2,
    AssetError = 3,
    ContractInvalid = 4,
    /** ContractNotFound - ContractNotFound is returned when the called contract does not exist. */
    ContractNotFound = 5,
    FeeInvalid = 6,
    ParameterInvalid = 7,
    APRInvalid = 8,
    AssetIDInvalid = 9,
    AssetTypeInvalid = 10,
    AssetCantBeMinted = 11,
    AssetCantBeBurned = 12,
    AssetCantBePaused = 13,
    AssetCantBeDelegated = 14,
    AssetOwnerCantBeChanged = 15,
    AccountNotOwner = 16,
    CommissionTooHigh = 17,
    DelegationAmountInvalid = 18,
    ProposalNotActive = 19,
    ValueInvalid = 20,
    AmountInvalid = 21,
    BucketIDInvalid = 22,
    KeyConflict = 23,
    MaxDelegationAmount = 24,
    InvalidPeerKey = 25,
    MinKFIStakedUnreached = 26,
    MaxSupplyExceeded = 27,
    SaveAccountError = 28,
    LoadAccountError = 29,
    SameAccountError = 30,
    AssetPaused = 31,
    DeletegateError = 32,
    WithdrawNotAvailable = 33,
    ErrOverflow = 34,
    SetStakingErr = 35,
    SetMarketOrderErr = 36,
    BalanceError = 37,
    KAPPError = 38,
    UnfreezeError = 39,
    UndelegateError = 40,
    WithdrawError = 41,
    ClaimError = 42,
    BucketsExceeded = 43,
    AssetCantBeWiped = 44,
    AssetCantAddRoles = 45,
    FreezeError = 46,
    ITONotActive = 47,
    NFTMintStopped = 48,
    RoyaltiesChangeStopped = 49,
    ITOKAPPError = 50,
    ITOWhiteListError = 51,
    NFTMetadataChangeStopped = 52,
    AlreadyExists = 53,
    IteratorLimitReached = 54,
    /** VMFunctionNotFound - FunctionNotFound is returned when the input specifies a function name that does not exist or is not public. */
    VMFunctionNotFound = 55,
    /** VMFunctionWrongSignature - FunctionWrongSignature is returned when the wrong number of arguments is provided. */
    VMFunctionWrongSignature = 56,
    /** VMUserError - UserError is returned for various execution errors. */
    VMUserError = 57,
    /** VMOutOfGas - OutOfGas is returned when VM execution runs out of gas. */
    VMOutOfGas = 58,
    /** VMAccountCollision - AccountCollision is returned when created account already exists. */
    VMAccountCollision = 59,
    /** VMCallStackOverFlow - CallStackOverFlow is returned when stack overflow occurs. */
    VMCallStackOverFlow = 60,
    /** VMExecutionPanicked - Execution Panicked */
    VMExecutionPanicked = 61,
    /** VMExecutionFailed - ExecutionFailed is returned when the execution of the specified function has failed. */
    VMExecutionFailed = 62,
    /** VMUpgradeFailed - UpgradeFailed is returned when the upgrade of the contract has failed */
    VMUpgradeFailed = 63,
    /** VMSimulateFailed - SimulateFailed is returned when tx simulation fails execution */
    VMSimulateFailed = 64,
    /** KDATransferNotAllowed - KDA Transfer not allowed */
    KDATransferNotAllowed = 65,
    Fail = 99,
    UNRECOGNIZED = -1
}
export declare function transaction_TXResultCodeFromJSON(object: any): Transaction_TXResultCode;
export declare function transaction_TXResultCodeToJSON(object: Transaction_TXResultCode): number;
export interface Transaction_KDAFee {
    KDA?: Uint8Array | undefined;
    /** TODO: allow spread */
    Amount?: number | undefined;
}
export interface Transaction_Raw {
    Nonce?: number | undefined;
    Sender?: Uint8Array | undefined;
    Contract?: TXContract[] | undefined;
    PermissionID?: number | undefined;
    Data?: Uint8Array[] | undefined;
    KAppFee?: number | undefined;
    BandwidthFee?: number | undefined;
    Version?: number | undefined;
    ChainID?: Uint8Array | undefined;
    KDAFee?: Transaction_KDAFee | undefined;
}
export interface Transaction_Receipt {
    Data?: Uint8Array[] | undefined;
}
export declare const TXContract: MessageFns<TXContract>;
export declare const Transaction: MessageFns<Transaction>;
export declare const Transaction_KDAFee: MessageFns<Transaction_KDAFee>;
export declare const Transaction_Raw: MessageFns<Transaction_Raw>;
export declare const Transaction_Receipt: MessageFns<Transaction_Receipt>;
type ProtoMetaMessageOptions = {
    options?: {
        [key: string]: any;
    };
    fields?: {
        [key: string]: {
            [key: string]: any;
        };
    };
    oneof?: {
        [key: string]: {
            [key: string]: any;
        };
    };
    nested?: {
        [key: string]: ProtoMetaMessageOptions;
    };
};
export interface ProtoMetadata {
    fileDescriptor: FileDescriptorProto;
    references: {
        [key: string]: any;
    };
    dependencies?: ProtoMetadata[];
    options?: {
        options?: {
            [key: string]: any;
        };
        services?: {
            [key: string]: {
                options?: {
                    [key: string]: any;
                };
                methods?: {
                    [key: string]: {
                        [key: string]: any;
                    };
                };
            };
        };
        messages?: {
            [key: string]: ProtoMetaMessageOptions;
        };
        enums?: {
            [key: string]: {
                options?: {
                    [key: string]: any;
                };
                values?: {
                    [key: string]: {
                        [key: string]: any;
                    };
                };
            };
        };
    };
}
export declare const protoMetadata: ProtoMetadata;
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & {
    [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
};
export interface MessageFns<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter;
    decode(input: BinaryReader | Uint8Array, length?: number): T;
    fromJSON(object: any): T;
    toJSON(message: T): unknown;
    create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
    fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
export {};
